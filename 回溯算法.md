# 回溯算法

解决一个回溯问题，实际上就是遍历一棵决策树的过程，树的每个叶子结点存放着一个合法答案。你把整棵树遍历一遍，把叶子结点上的答案都收集起来，就能得到所有的合法答案。

* 全排列问题
* N皇后问题

### 站在回溯树的一个节点上，核心思考点
1. 路径：也就是已经做出的选择。
2. 选择列表：也就是你当前可以做的选择。
3. 结束条件：也就是到达决策树底层，无法再做选择的条件。

### Demo
```
function backtrack(...) {
    if (到达叶子节点) {
        return;
    }

    for (let i = 0; i < n; i++) {
        // 做选择
        ...
        backtrack(...);
        // 撤销选择
        ...
    }
}
```

### N皇后问题
```
function solveNQueens(n) {
    let res = [];
    // 每个字符串代表一行，字符串列代表一个棋盘
    // '.'表示空，'Q'表示皇后，初始化空棋盘
    let board = new Array(n).fill('.').map(() => new Array(n).fill('.').join(''));
    backtrack(res, board, 0);
    return res;

    // 路径：board中小于row的那些行都已经放置了皇后
    // 选择列表：第row行所有的列都可以放置皇后的选择
    // 结束条件：row超过board的最后一行
    function backtrack(res, board, row) {
        // 触发结束条件
        if (row === board.length) {
            res.push([...board]);
            return;
        }

        const n = board[row].length;
        for (let col = 0; col < n; col++) {
            // 排除不合法的选择
            if (!isValid(board, row, col)) {
                continue;
            }
            // 做选择
            let rowCharts = board[row].split('');
            rowCharts[col] = 'Q';
            board[row] = rowCharts.join('');

            // 进入下一行决策
            backtrack(res, board, row + 1);
            // 撤销选择
            rowCharts[col] = '.';
            board[row] = rowCharts.join('');
        }
    }

    // 是否可以在board[row][col]放置皇后？
    function isValid(board, row, col) {
        const n = board.length;
        // 检查列是否有皇后互相冲突
        for (let i = 0; i <= row; i++) {
            if (board[i][col] === 'Q') {
                return false;
            }
        }

        let i = row - 1;
        let j = col - 1;
        // 检查左上方是否有皇后互相冲突
        while (i >= 0 && j >= 0) {
            if (board[i][j] === 'Q') {
                return false;
            }
            i--;
            j--;
        }
        i = row - 1;
        j = col + 1;
        while (i >= 0 && j < n) {
            if (board[i][j] === 'Q') {
                return false;
            }
            i--;
            j++;
        }
        return true;

    }
}
```